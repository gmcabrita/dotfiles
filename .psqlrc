\set QUIET 1

\pset null 'ðŸ‘»'
\x auto
\timing

\set HISTFILE ~/.psql_history- :DBNAME
\set HISTCONTROL ignoredups
\set COMP_KEYWORD_CASE upper

\set PROMPT1 '%n@%/%R%#%x '
\set PROMPT2 '[more] %R> '

\pset linestyle unicode
\pset border 2

\set version 'SELECT version();'
\set extensions 'select * from pg_available_extensions;'
\set long_running 'SELECT pid, now() - pg_stat_activity.xact_start AS duration, query, state, wait_event, wait_event_type, pg_blocking_pids(pid) FROM pg_stat_activity WHERE (now() - pg_stat_activity.xact_start) > interval ''5 minutes'' ORDER by 2 DESC;'
\set databases 'WITH DATA AS (SELECT d.oid, (SELECT spcname FROM pg_tablespace WHERE oid = dattablespace) AS tblspace, d.datname AS database_name, pg_catalog.pg_get_userbyid(d.datdba) AS OWNER, has_database_privilege(d.datname, ''connect'') AS has_access, pg_database_size(d.datname) AS SIZE, stats_reset, blks_hit, blks_read, xact_commit, xact_rollback, conflicts, deadlocks, temp_files, temp_bytes FROM pg_catalog.pg_database d JOIN pg_stat_database s ON s.datid = d.oid), data2 AS (SELECT NULL::oid AS oid, NULL AS tblspace, ''*** TOTAL ***'' AS database_name, NULL AS OWNER, TRUE AS has_access, sum(SIZE) AS SIZE, NULL::timestamptz AS stats_reset, sum(blks_hit) AS blks_hit, sum(blks_read) AS blks_read, sum(xact_commit) AS xact_commit, sum(xact_rollback) AS xact_rollback, sum(conflicts) AS conflicts, sum(deadlocks) AS deadlocks, sum(temp_files) AS temp_files, sum(temp_bytes) AS temp_bytes FROM DATA UNION ALL SELECT NULL::oid, NULL, NULL, NULL, TRUE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL UNION ALL SELECT oid, tblspace, database_name, OWNER, has_access, SIZE, stats_reset, blks_hit, blks_read, xact_commit, xact_rollback, conflicts, deadlocks, temp_files, temp_bytes FROM DATA) SELECT database_name || coalesce('' ['' || nullif(tblspace, ''pg_default'') || '']'', '''') AS "Database", CASE WHEN has_access THEN pg_size_pretty(SIZE) || '' ('' || round(100 * SIZE::numeric / nullif(sum(SIZE) OVER (PARTITION BY (oid IS NULL)), 0), 2)::text || ''%)'' ELSE ''no access'' END AS "Size", (now() - stats_reset)::interval(0)::text AS "Stats Age", CASE WHEN blks_hit + blks_read > 0 THEN (round(blks_hit * 100::numeric / (blks_hit + blks_read), 2))::text || ''%'' ELSE NULL END AS "Cache eff.", CASE WHEN xact_commit + xact_rollback > 0 THEN (round(xact_commit * 100::numeric / (xact_commit + xact_rollback), 2))::text || ''%'' ELSE NULL END AS "Committed", conflicts AS "Conflicts", deadlocks AS "Deadlocks", temp_files::text || coalesce('' ('' || pg_size_pretty(temp_bytes) || '')'', '''') AS "Temp. Files" FROM data2 ORDER BY oid IS NULL DESC, SIZE DESC NULLS LAST;'
\set tables 'WITH DATA AS (SELECT c.oid, (SELECT spcname FROM pg_tablespace WHERE oid = reltablespace) AS tblspace, nspname AS SCHEMA_NAME, relname AS TABLE_NAME, c.reltuples AS row_estimate, pg_total_relation_size(c.oid) AS total_bytes, pg_indexes_size(c.oid) AS index_bytes, pg_total_relation_size(reltoastrelid) AS toast_bytes, pg_total_relation_size(c.oid) - pg_indexes_size(c.oid) - coalesce(pg_total_relation_size(reltoastrelid), 0) AS table_bytes FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = c.relnamespace WHERE relkind = ''r'' AND nspname <> ''pg_catalog'' ), data2 AS (SELECT NULL::oid AS oid, NULL AS tblspace, NULL AS SCHEMA_NAME, ''*** TOTAL ***'' AS TABLE_NAME, sum(row_estimate) AS row_estimate, sum(total_bytes) AS total_bytes, sum(index_bytes) AS index_bytes, sum(toast_bytes) AS toast_bytes, sum(table_bytes) AS table_bytes FROM DATA UNION ALL SELECT NULL::oid AS oid, NULL, NULL AS SCHEMA_NAME, '' tablespace: ['' || coalesce(tblspace, ''pg_default'') || '']'' AS TABLE_NAME, sum(row_estimate) AS row_estimate, sum(total_bytes) AS total_bytes, sum(index_bytes) AS index_bytes, sum(toast_bytes) AS toast_bytes, sum(table_bytes) AS table_bytes FROM DATA WHERE (SELECT count(DISTINCT coalesce(tblspace, ''pg_default'')) FROM DATA) > 1 GROUP BY tblspace UNION ALL SELECT NULL::oid, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL UNION ALL SELECT * FROM DATA) SELECT coalesce(nullif(SCHEMA_NAME, ''public'') || ''.'', '''') || TABLE_NAME || coalesce('' ['' || tblspace || '']'', '''') AS "Table", ''~'' || CASE WHEN row_estimate > 10^12 THEN round(row_estimate::numeric / 10^12::numeric, 0)::text || ''T'' WHEN row_estimate > 10^9 THEN round(row_estimate::numeric / 10^9::numeric, 0)::text || ''B'' WHEN row_estimate > 10^6 THEN round(row_estimate::numeric / 10^6::numeric, 0)::text || ''M'' WHEN row_estimate > 10^3 THEN round(row_estimate::numeric / 10^3::numeric, 0)::text || ''k'' ELSE row_estimate::text END AS "Rows", pg_size_pretty(total_bytes) || '' ('' || round(100 * total_bytes::numeric / nullif(sum(total_bytes) OVER (PARTITION BY (SCHEMA_NAME IS NULL), left(TABLE_NAME, 3) = ''***''), 0), 2)::text || ''%)'' AS "Total Size", pg_size_pretty(table_bytes) || '' ('' || round(100 * table_bytes::numeric / nullif(sum(table_bytes) OVER (PARTITION BY (SCHEMA_NAME IS NULL), left(TABLE_NAME, 3) = ''***''), 0), 2)::text || ''%)'' AS "Table Size", pg_size_pretty(index_bytes) || '' ('' || round(100 * index_bytes::numeric / nullif(sum(index_bytes) OVER (PARTITION BY (SCHEMA_NAME IS NULL), left(TABLE_NAME, 3) = ''***''), 0), 2)::text || ''%)'' AS "Index(es) Size", pg_size_pretty(toast_bytes) || '' ('' || round(100 * toast_bytes::numeric / nullif(sum(toast_bytes) OVER (PARTITION BY (SCHEMA_NAME IS NULL), left(TABLE_NAME, 3) = ''***''), 0), 2)::text || ''%)'' AS "TOAST Size" FROM data2 WHERE SCHEMA_NAME IS DISTINCT FROM ''information_schema'' ORDER BY oid IS NULL DESC, total_bytes DESC NULLS LAST;'
\set activity 'SELECT coalesce(usename, ''** ALL users **'') AS "User", coalesce(datname, ''** ALL databases **'') AS "DB", coalesce(state, ''** ALL states **'') AS "Current State", count(*) AS "Count", count(*) filter ( WHERE state_change < now() - interval ''1 minute'') AS "State changed >1m ago", count(*) filter ( WHERE state_change < now() - interval ''1 hour'') AS "State changed >1h ago" FROM pg_stat_activity GROUP BY GROUPING SETS ((datname, usename, state), (usename, state), ()) ORDER BY usename IS NULL DESC, datname IS NULL DESC, 2 ASC, 3 ASC, count(*) DESC ;'
\set table_bloat_estimation 'WITH step1 AS (SELECT tbl.oid tblid, ns.nspname AS SCHEMA_NAME, tbl.relname AS TABLE_NAME, tbl.reltuples, tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages, coalesce(toast.reltuples, 0) AS toasttuples, coalesce(substring(array_to_string(tbl.reloptions, '' '') FROM ''%fillfactor=#"__#"%'' FOR ''#'')::int2, 100) AS fillfactor, current_setting(''block_size'')::numeric AS bs, CASE WHEN version() ~ ''mingw32|64-bit|x86_64|ppc64|ia64|amd64'' THEN 8 ELSE 4 END AS ma, 24 AS page_hdr, 23 + CASE WHEN max(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8 ELSE 0::int END + CASE WHEN bool_or(att.attname = ''oid'' AND att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size, sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size, bool_or(att.atttypid = ''pg_catalog.name''::regtype) OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na FROM pg_attribute AS att JOIN pg_class AS tbl ON att.attrelid = tbl.oid AND tbl.relkind = ''r'' JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace JOIN pg_stats AS s ON s.schemaname = ns.nspname AND s.tablename = tbl.relname AND NOT s.inherited AND s.attname = att.attname LEFT JOIN pg_class AS TOAST ON tbl.reltoastrelid = toast.oid WHERE NOT att.attisdropped AND s.schemaname not in (''pg_catalog'', ''information_schema'') GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ORDER BY 2, 3), step2 AS (SELECT *, (4 + tpl_hdr_size + tpl_data_size + (2 * ma) - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END - CASE WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma ELSE ceil(tpl_data_size)::int % ma END) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages FROM step1), step3 AS (SELECT *, ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) AS est_tblpages, ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) + ceil(toasttuples / 4) AS est_tblpages_ff FROM step2), step4 AS (SELECT *, tblpages * bs AS real_size, (tblpages - est_tblpages) * bs AS extra_size, CASE WHEN tblpages - est_tblpages > 0 THEN 100 * (tblpages - est_tblpages) / tblpages::float ELSE 0 END AS extra_ratio, (tblpages - est_tblpages_ff) * bs AS bloat_size, CASE WHEN tblpages - est_tblpages_ff > 0 THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float ELSE 0 END AS bloat_ratio FROM step3 LEFT JOIN pg_stat_user_tables su ON su.relid = tblid ) SELECT CASE is_na WHEN TRUE THEN ''TRUE'' ELSE '''' END AS "Is N/A", coalesce(nullif(SCHEMA_NAME, ''public'') || ''.'', '''') || TABLE_NAME AS "Table", pg_size_pretty(real_size::numeric) AS "Size", CASE WHEN extra_size::numeric >= 0 THEN ''~'' || pg_size_pretty(extra_size::numeric)::text || '' ('' || round(extra_ratio::numeric, 2)::text || ''%)'' ELSE NULL END AS "Extra", CASE WHEN bloat_size::numeric >= 0 THEN ''~'' || pg_size_pretty(bloat_size::numeric)::text || '' ('' || round(bloat_ratio::numeric, 2)::text || ''%)'' ELSE NULL END AS "Bloat estimate", CASE WHEN (real_size - bloat_size)::numeric >=0 THEN ''~'' || pg_size_pretty((real_size - bloat_size)::numeric) ELSE NULL END AS "Live", greatest(last_autovacuum, last_vacuum)::timestamp(0)::text || CASE greatest(last_autovacuum, last_vacuum) WHEN last_autovacuum THEN '' (auto)'' ELSE '''' END AS "Last Vaccuum", (SELECT coalesce(substring(array_to_string(reloptions, '' '') FROM ''fillfactor=([0-9]+)'')::smallint, 100) FROM pg_class WHERE oid = tblid ) AS "Fillfactor" FROM step4 ORDER BY bloat_size DESC NULLS LAST;'
\set btree_bloat_estimation 'WITH step1 AS (SELECT i.nspname AS SCHEMA_NAME, i.tblname AS TABLE_NAME, i.idxname AS index_name, i.reltuples, i.relpages, i.relam, a.attrelid AS table_oid, current_setting(''block_size'')::numeric AS bs, fillfactor, CASE WHEN version() ~ ''mingw32|64-bit|x86_64|ppc64|ia64|amd64'' THEN 8 ELSE 4 END AS maxalign, 24 AS pagehdr, 16 AS pageopqdata, CASE WHEN max(coalesce(s.null_frac, 0)) = 0 THEN 2 ELSE 2 + ((32 + 8 - 1) / 8) END AS index_tuple_hdr_bm, sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS nulldatawidth, max(CASE WHEN a.atttypid = ''pg_catalog.name''::regtype THEN 1 ELSE 0 END) > 0 AS is_na FROM pg_attribute AS a JOIN (SELECT nspname, tbl.relname AS tblname, idx.relname AS idxname, idx.reltuples, idx.relpages, idx.relam, indrelid, indexrelid, indkey::smallint[] AS attnum, coalesce(substring(array_to_string(idx.reloptions, '' '') FROM ''fillfactor=([0-9]+)'')::smallint, 90) AS fillfactor FROM pg_index JOIN pg_class idx ON idx.oid = pg_index.indexrelid JOIN pg_class tbl ON tbl.oid = pg_index.indrelid JOIN pg_namespace ON pg_namespace.oid = idx.relnamespace WHERE pg_index.indisvalid AND tbl.relkind = ''r'' AND idx.relpages > 0 ) AS i ON a.attrelid = i.indexrelid JOIN pg_stats AS s ON s.schemaname = i.nspname AND ((s.tablename = i.tblname AND s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE)) OR (s.tablename = i.idxname AND s.attname = a.attname) ) JOIN pg_type AS t ON a.atttypid = t.oid WHERE a.attnum > 0 GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9), step2 AS (SELECT *, (index_tuple_hdr_bm + maxalign - CASE WHEN index_tuple_hdr_bm % maxalign = 0 THEN maxalign ELSE index_tuple_hdr_bm % maxalign END + nulldatawidth + maxalign - CASE WHEN nulldatawidth = 0 THEN 0 WHEN nulldatawidth::integer % maxalign = 0 THEN maxalign ELSE nulldatawidth::integer % maxalign END)::numeric AS nulldatahdrwidth FROM step1), step3 AS (SELECT *, coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) / (4 + nulldatahdrwidth)::float)), 0) AS est_pages, coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) * fillfactor / (100 * (4 + nulldatahdrwidth)::float))), 0) AS est_pages_ff FROM step2 JOIN pg_am am ON step2.relam = am.oid WHERE am.amname = ''btree'' ), step4 AS (SELECT *, bs*(relpages)::bigint AS real_size, bs*(relpages-est_pages)::bigint AS extra_size, 100 * (relpages-est_pages)::float / relpages AS extra_ratio, bs*(relpages-est_pages_ff) AS bloat_size, 100 * (relpages-est_pages_ff)::float / relpages AS bloat_ratio FROM step3 ) SELECT CASE is_na WHEN TRUE THEN ''TRUE'' ELSE '''' END AS "Is N/A", format($out$%s (%s)$out$, left(index_name, 50) || CASE WHEN length(index_name) > 50 THEN ''â€¦'' ELSE '''' END, coalesce(nullif(SCHEMA_NAME, ''public'') || ''.'', '''') || TABLE_NAME) AS "Index (Table)", pg_size_pretty(real_size::numeric) AS "Size", CASE WHEN extra_size::numeric >= 0 THEN ''~'' || pg_size_pretty(extra_size::numeric)::text || '' ('' || round(extra_ratio::numeric, 2)::text || ''%)'' ELSE NULL END AS "Extra", CASE WHEN bloat_size::numeric >= 0 THEN ''~'' || pg_size_pretty(bloat_size::numeric)::text || '' ('' || round(bloat_ratio::numeric, 2)::text || ''%)'' ELSE NULL END AS "Bloat", CASE WHEN (real_size - bloat_size)::numeric >=0 THEN ''~'' || pg_size_pretty((real_size - bloat_size)::numeric) ELSE NULL END AS "Live", fillfactor FROM step4 ORDER BY real_size DESC NULLS LAST ;'
\set rare_indexes 'WITH table_scans AS (SELECT relid, tables.idx_scan + tables.seq_scan AS all_scans, (tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del) AS writes, pg_relation_size(relid) AS table_size FROM pg_stat_user_tables AS TABLES), all_writes AS (SELECT sum(writes) AS total_writes FROM table_scans), INDEXES AS (SELECT idx_stat.relid, idx_stat.indexrelid, idx_stat.schemaname, idx_stat.relname AS tablename, idx_stat.indexrelname AS indexname, idx_stat.idx_scan, pg_relation_size(idx_stat.indexrelid) AS index_bytes, indexdef ~* ''USING btree'' AS idx_is_btree FROM pg_stat_user_indexes AS idx_stat JOIN pg_index USING (indexrelid) JOIN pg_indexes AS INDEXES ON idx_stat.schemaname = indexes.schemaname AND idx_stat.relname = indexes.tablename AND idx_stat.indexrelname = indexes.indexname WHERE pg_index.indisunique = FALSE ), index_ratios AS (SELECT schemaname, tablename, indexname, idx_scan, all_scans, round((CASE WHEN all_scans = 0 THEN 0.0::NUMERIC ELSE idx_scan::NUMERIC/all_scans * 100 END),2) AS index_scan_pct, writes, round((CASE WHEN writes = 0 THEN idx_scan::NUMERIC ELSE idx_scan::NUMERIC/writes END),2) AS scans_per_write, pg_size_pretty(index_bytes) AS index_size, pg_size_pretty(table_size) AS table_size, idx_is_btree, index_bytes FROM INDEXES JOIN table_scans USING (relid)), index_groups AS (SELECT ''Never Used Indexes'' AS reason, *, 1 AS grp FROM index_ratios WHERE idx_scan = 0 AND idx_is_btree UNION ALL SELECT ''Low Scans, High Writes'' AS reason, *, 2 AS grp FROM index_ratios WHERE scans_per_write <= 1 AND index_scan_pct < 10 AND idx_scan > 0 AND writes > 100 AND idx_is_btree UNION ALL SELECT ''Seldom Used Large Indexes'' AS reason, *, 3 AS grp FROM index_ratios WHERE index_scan_pct < 5 AND scans_per_write > 1 AND idx_scan > 0 AND idx_is_btree AND index_bytes > 100000000 UNION ALL SELECT ''High-Write Large Non-Btree'' AS reason, index_ratios.*, 4 AS grp FROM index_ratios, all_writes WHERE (writes::NUMERIC / (total_writes + 1)) > 0.02 AND NOT idx_is_btree AND index_bytes > 100000000 ORDER BY grp, index_bytes DESC) SELECT reason, schemaname AS SCHEMA_NAME, tablename AS TABLE_NAME, indexname AS index_name, index_scan_pct, scans_per_write, index_size, table_size, idx_scan, all_scans FROM index_groups ;'
\set redundant_indexes 'WITH fk_indexes AS (SELECT n.nspname AS SCHEMA_NAME, ci.relname AS index_name, cr.relname AS TABLE_NAME, (confrelid::regclass)::text AS fk_table_ref, array_to_string(indclass, ', ') AS opclasses FROM pg_index i JOIN pg_class ci ON ci.oid = i.indexrelid AND ci.relkind = 'i' JOIN pg_class cr ON cr.oid = i.indrelid AND cr.relkind = 'r' JOIN pg_namespace n ON n.oid = ci.relnamespace JOIN pg_constraint cn ON cn.conrelid = cr.oid LEFT JOIN pg_stat_user_indexes si ON si.indexrelid = i.indexrelid WHERE contype = 'f' AND i.indisunique IS FALSE AND conkey IS NOT NULL AND ci.relpages > 0 AND si.idx_scan < 10 ), index_data AS (SELECT *, (SELECT string_agg(lpad(i, 3, '0'), ' ') FROM unnest(string_to_array(indkey::text, ' ')) i) AS columns, array_to_string(indclass, ', ') AS opclasses FROM pg_index i JOIN pg_class ci ON ci.oid = i.indexrelid AND ci.relkind = 'i' WHERE indisvalid = TRUE AND ci.relpages > 0 ), redundant_indexes AS (SELECT i2.indexrelid AS index_id, tnsp.nspname AS SCHEMA_NAME, trel.relname AS TABLE_NAME, pg_relation_size(trel.oid) AS table_size_bytes, irel.relname AS index_name, am1.amname AS access_method, (i1.indexrelid::regclass)::text AS reason, i1.indexrelid AS reason_index_id, pg_get_indexdef(i1.indexrelid) main_index_def, pg_size_pretty(pg_relation_size(i1.indexrelid)) main_index_size, pg_get_indexdef(i2.indexrelid) index_def, pg_relation_size(i2.indexrelid) index_size_bytes, s.idx_scan AS index_usage, quote_ident(tnsp.nspname) AS formated_schema_name, coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(irel.relname) AS formated_index_name, quote_ident(trel.relname) AS formated_table_name, coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(trel.relname) AS formated_relation_name, i2.opclasses FROM index_data AS i1 JOIN index_data AS i2 ON (i1.indrelid = i2.indrelid AND i1.indexrelid <> i2.indexrelid ) INNER JOIN pg_opclass op1 ON i1.indclass[0] = op1.oid INNER JOIN pg_opclass op2 ON i2.indclass[0] = op2.oid INNER JOIN pg_am am1 ON op1.opcmethod = am1.oid INNER JOIN pg_am am2 ON op2.opcmethod = am2.oid JOIN pg_stat_user_indexes AS s ON s.indexrelid = i2.indexrelid JOIN pg_class AS trel ON trel.oid = i2.indrelid JOIN pg_namespace AS tnsp ON trel.relnamespace = tnsp.oid JOIN pg_class AS irel ON irel.oid = i2.indexrelid WHERE NOT i2.indisprimary AND NOT (i2.indisunique AND NOT i1.indisprimary) AND am1.amname = am2.amname AND i1.columns like (i2.columns || '%') AND i1.opclasses like (i2.opclasses || '%') AND pg_get_expr(i1.indexprs, i1.indrelid) IS NOT DISTINCT FROM pg_get_expr(i2.indexprs, i2.indrelid) AND pg_get_expr(i1.indpred, i1.indrelid) IS NOT DISTINCT FROM pg_get_expr(i2.indpred, i2.indrelid) ), redundant_indexes_fk AS (SELECT ri.*, (SELECT count(1) FROM fk_indexes fi WHERE fi.fk_table_ref = ri.table_name AND fi.opclasses like (ri.opclasses || '%') ) > 0 AS supports_fk FROM redundant_indexes ri), redundant_indexes_tmp_num AS (SELECT row_number() OVER () num, rig.* FROM redundant_indexes_fk rig ORDER BY index_id), redundant_indexes_tmp_cut AS (SELECT ri1.*, ri2.num AS r_num FROM redundant_indexes_tmp_num ri1 LEFT JOIN redundant_indexes_tmp_num ri2 ON ri2.reason_index_id = ri1.index_id AND ri1.reason_index_id = ri2.index_id WHERE ri1.num < ri2.num OR ri2.num IS NULL ), redundant_indexes_cut_grouped AS (SELECT distinct(num), * FROM redundant_indexes_tmp_cut ORDER BY index_size_bytes DESC), redundant_indexes_grouped AS (SELECT distinct(num), * FROM redundant_indexes_tmp_cut ORDER BY index_size_bytes DESC) SELECT SCHEMA_NAME, TABLE_NAME, table_size_bytes, index_name, access_method, string_agg(DISTINCT reason, ', ') AS redundant_to, string_agg(main_index_def, ', ') AS main_index_def, string_agg(main_index_size, ', ') AS main_index_size, index_def, index_size_bytes, index_usage, supports_fk FROM redundant_indexes_cut_grouped GROUP BY index_id, SCHEMA_NAME, TABLE_NAME, table_size_bytes, index_name, access_method, index_def, index_size_bytes, index_usage, supports_fk ORDER BY index_size_bytes DESC;'
\set non_indexed_fks 'WITH fk_actions (code, action) AS ( VALUES (''a'', ''error''), (''r'', ''restrict''), (''c'', ''cascade''), (''n'', ''set null''), (''d'', ''set default'')), fk_list AS (SELECT pg_constraint.oid AS fkoid, conrelid, confrelid AS parentid, conname, relname, nspname, fk_actions_update.action AS update_action, fk_actions_delete.action AS delete_action, conkey AS key_cols FROM pg_constraint JOIN pg_class ON conrelid = pg_class.oid JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid JOIN fk_actions AS fk_actions_update ON confupdtype = fk_actions_update.code JOIN fk_actions AS fk_actions_delete ON confdeltype = fk_actions_delete.code WHERE contype = ''f'' ), fk_attributes AS (SELECT fkoid, conrelid, attname, attnum FROM fk_list JOIN pg_attribute ON conrelid = attrelid AND attnum = any(key_cols) ORDER BY fkoid, attnum), fk_cols_list AS (SELECT fkoid, array_agg(attname) AS cols_list FROM fk_attributes GROUP BY fkoid), index_list AS (SELECT indexrelid AS indexid, pg_class.relname AS indexname, indrelid, indkey, indpred IS NOT NULL AS has_predicate, pg_get_indexdef(indexrelid) AS indexdef FROM pg_index JOIN pg_class ON indexrelid = pg_class.oid WHERE indisvalid ), fk_index_match AS (SELECT fk_list.*, indexid, indexname, indkey::int[] AS indexatts, has_predicate, indexdef, array_length(key_cols, 1) AS fk_colcount, array_length(indkey, 1) AS index_colcount, round(pg_relation_size(conrelid)/(1024^2)::numeric) AS table_mb, cols_list FROM fk_list JOIN fk_cols_list USING (fkoid) LEFT JOIN index_list ON conrelid = indrelid AND (indkey::int2[])[0:(array_length(key_cols, 1) -1)] operator(pg_catalog.@>) key_cols), fk_perfect_match AS (SELECT fkoid FROM fk_index_match WHERE (index_colcount - 1) <= fk_colcount AND NOT has_predicate AND indexdef like ''%USING btree%'' ), fk_index_check AS (SELECT ''no index'' AS issue, *, 1 AS issue_sort FROM fk_index_match WHERE indexid IS NULL UNION ALL SELECT ''questionable index'' AS issue, *, 2 FROM fk_index_match WHERE indexid IS NOT NULL AND fkoid not in (SELECT fkoid FROM fk_perfect_match) ), parent_table_stats AS (SELECT fkoid, tabstats.relname AS parent_name, (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) AS parent_writes, round(pg_relation_size(parentid)/(1024^2)::numeric) AS parent_mb FROM pg_stat_user_tables AS tabstats JOIN fk_list ON relid = parentid), fk_table_stats AS (SELECT fkoid, (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) AS writes, seq_scan AS table_scans FROM pg_stat_user_tables AS tabstats JOIN fk_list ON relid = conrelid) SELECT nspname AS SCHEMA_NAME, relname AS TABLE_NAME, conname AS fk_name, issue, table_mb, writes, table_scans, parent_name, parent_mb, parent_writes, cols_list, indexdef FROM fk_index_check JOIN parent_table_stats USING (fkoid) JOIN fk_table_stats USING (fkoid) WHERE table_mb > 9 AND (writes > 1000 OR parent_writes > 1000 OR parent_mb > 10) ORDER BY issue_sort, table_mb DESC, TABLE_NAME, fk_name;'
\set invalid_indexes 'SELECT coalesce(nullif(pn.nspname, ''public'') || ''.'', '''') || pct.relname AS "relation_name", pci.relname AS index_name, pn.nspname AS SCHEMA_NAME, pct.relname AS TABLE_NAME, pg_size_pretty(pg_relation_size(pidx.indexrelid)) index_size, format(''DROP INDEX CONCURRENTLY %s; -- %s, table %s'', pidx.indexrelid::regclass::text, ''Invalid index'', pct.relname) AS drop_code, replace(format(''%s; -- table %s'', pg_get_indexdef(pidx.indexrelid), pct.relname), ''CREATE INDEX'', ''CREATE INDEX CONCURRENTLY'') AS revert_code FROM pg_index pidx JOIN pg_class AS pci ON pci.oid = pidx.indexrelid JOIN pg_class AS pct ON pct.oid = pidx.indrelid LEFT JOIN pg_namespace pn ON pn.oid = pct.relnamespace WHERE pidx.indisvalid = FALSE;'
\set lock_trees 'with recursive l as ( select pid, locktype, granted, array_position(array[''accessshare'',''rowshare'',''rowexclusive'',''shareupdateexclusive'',''share'',''sharerowexclusive'',''exclusive'',''accessexclusive''], left(mode,-4)) m, row(locktype,database,relation,page,tuple,virtualxid,transactionid,classid,objid,objsubid) obj from pg_locks ), pairs as ( select w.pid waiter, l.pid locker, l.obj, l.m from l w join l on l.obj is not distinct from w.obj and l.locktype=w.locktype and not l.pid=w.pid and l.granted where not w.granted and not exists ( select from l i where i.pid=l.pid and i.locktype=l.locktype and i.obj is not distinct from l.obj and i.m > l.m ) ), leads as ( select o.locker, 1::int lvl, count(*) q, array[locker] track, false as cycle from pairs o group by o.locker union all select i.locker, leads.lvl+1, (select count(*) from pairs q where q.locker=i.locker), leads.track||i.locker, i.locker=any(leads.track) from pairs i, leads where i.waiter=leads.locker and not cycle ), tree as ( select locker pid,locker dad,locker root,case when cycle then track end dl, null::record obj,0 lvl,locker::text path,array_agg(locker) over () all_pids from leads o where (cycle and not exists (select from leads i where i.locker=any(o.track) and (i.lvl>o.lvl or i.q<o.q))) or (not cycle and not exists (select from pairs where waiter=o.locker) and not exists (select from leads i where i.locker=o.locker and i.lvl<o.lvl)) union all select w.waiter pid,tree.pid,tree.root,case when w.waiter=any(tree.dl) then tree.dl end,w.obj,tree.lvl+1,tree.path||''.''||w.waiter,all_pids || array_agg(w.waiter) over () from tree join pairs w on tree.pid=w.locker and not w.waiter = any ( all_pids ) ) select (clock_timestamp() - a.xact_start)::interval(0) as ts_age, (clock_timestamp() - a.state_change)::interval(0) as change_age, a.datname,a.usename,a.client_addr, tree.pid,replace(a.state, ''idle in transaction'', ''idletx'') state, lvl,(select count(*) from tree p where p.path ~ (''^''||tree.path) and not p.path=tree.path) blocked, case when tree.pid=any(tree.dl) then ''!>'' else repeat('' .'', lvl) end||'' ''||trim(left(regexp_replace(a.query, e''\\s+'', '' '', ''g''),100)) query from tree left join pairs w on w.waiter=tree.pid and w.locker=tree.dad join pg_stat_activity a using (pid) join pg_stat_activity r on r.pid=tree.root order by (now() - r.xact_start), path;'
\set lock_trees_detailed 'BEGIN; SET LOCAL statement_timeout TO ''100ms''; WITH RECURSIVE activity AS (SELECT pg_blocking_pids(pid) blocked_by, *, age(clock_timestamp(), xact_start)::interval(0) AS tx_age, age(clock_timestamp(), state_change)::interval(0) AS state_age FROM pg_stat_activity WHERE state IS DISTINCT FROM ''idle'' ), blockers AS (SELECT array_agg(DISTINCT c ORDER BY c) AS pids FROM (SELECT unnest(blocked_by) FROM activity) AS dt(c)), tree AS (SELECT activity.*, 1 AS LEVEL, activity.pid AS top_blocker_pid, array[activity.pid] AS PATH, array[activity.pid]::int[] AS all_blockers_above FROM activity, blockers WHERE array[pid] <@ blockers.pids AND blocked_by = ''{}''::int[] UNION ALL SELECT activity.*, tree.level + 1 AS LEVEL, tree.top_blocker_pid, PATH || array[activity.pid] AS PATH, tree.all_blockers_above || array_agg(activity.pid) OVER () AS all_blockers_above FROM activity, tree WHERE NOT array[activity.pid] <@ tree.all_blockers_above AND activity.blocked_by <> ''{}''::int[] AND activity.blocked_by <@ tree.all_blockers_above ) SELECT pid, blocked_by, tx_age, state_age, backend_xid AS xid, backend_xmin AS xmin, replace(state, ''idle in transaction'', ''idletx'') AS state, datname, usename, wait_event_type || '':'' || wait_event AS wait, (SELECT count(DISTINCT t1.pid) FROM tree t1 WHERE array[tree.pid] <@ t1.path AND t1.pid <> tree.pid) AS blkd, format(''%s %s%s'', lpad(''['' || pid::text || '']'', 7, '' ''), repeat(''.'', LEVEL - 1) || CASE WHEN LEVEL > 1 THEN '' '' END, left(query, 1000)) AS query FROM tree ORDER BY top_blocker_pid, LEVEL, pid; COMMIT;'
\set pg_stat_statements_top_total 'select sum(calls) as calls, round(sum(total_exec_time)::numeric, 2) as total_exec_t, round((sum(mean_exec_time * calls) / sum(calls))::numeric, 2) as mean_exec_t, format( ''%sâ€“%s'', round(min(min_exec_time)::numeric, 2),  round(max(max_exec_time)::numeric, 2) ) as min_max_exec_t, round(sum(total_plan_time)::numeric, 2) as total_plan_t, round((sum(mean_plan_time * calls) / sum(calls))::numeric, 2) as mean_plan_t, format( ''%sâ€“%s'', round(min(min_plan_time)::numeric, 2),  round(max(max_plan_time)::numeric, 2) ) as min_max_plan_t, sum(rows) as rows, (select usename from pg_user where usesysid = userid) as usr, (select datname from pg_database where oid = dbid) as db, left(query, 100) as query, sum(shared_blks_hit) as shared_blks_hit, sum(shared_blks_read) as shared_blks_read, sum(shared_blks_dirtied) as shared_blks_dirtied, sum(shared_blks_written) as shared_blks_written, sum(local_blks_hit) as local_blks_hit, sum(local_blks_read) as local_blks_read, sum(local_blks_dirtied) as local_blks_dirtied, sum(local_blks_written) as local_blks_written, sum(temp_blks_read) as temp_blks_read, sum(temp_blks_written) as temp_blks_written, sum(blk_read_time) as blk_read_time, sum(blk_write_time) as blk_write_time, array_agg(queryid) as queryids from pg_stat_statements group by userid, dbid, query order by sum(total_exec_time) desc limit 50;'
\set pg_stat_statements_report 'with pg_stat_statements_slice as ( select * from pg_stat_statements where current_database() = ''postgres'' or dbid = ( select oid from pg_database where datname = current_database() ) ), pg_stat_statements_normalized as ( select *, translate( regexp_replace( regexp_replace( regexp_replace(   regexp_replace(     query,     e''\\?(::[a-zA-Z_]+)?( *, *\\?(::[a-zA-Z_]+)?)+'', ''?'', ''g''   ),   e''\\$[0-9]+(::[a-zA-Z_]+)?( *, *\\$[0-9]+(::[a-zA-Z_]+)?)*'', ''$N'', ''g'' ), e''--.*$'', '''', ''ng'' ), e''/\\*.*?\\*/'', '''', ''g'' ), e''\r'', '''' ) as query_normalized from pg_stat_statements_slice ), totals as ( select sum(total_exec_time) as total_exec_time, sum(blk_read_time+blk_write_time) as io_time, sum(total_exec_time-blk_read_time-blk_write_time) as non_io_time, sum(calls) as ncalls, sum(rows) as total_rows from pg_stat_statements_slice ), _pg_stat_statements as ( select (select datname from pg_database where oid = p.dbid) as database, (select rolname from pg_roles where oid = p.userid) as username, substring( translate( replace( (array_agg(query order by length(query)))[1], e''-- \n'', e''--\n'' ), e''\r'', '''' ), 1, 8192 ) as query, sum(total_exec_time) as total_exec_time, sum(blk_read_time) as blk_read_time, sum(blk_write_time) as blk_write_time, sum(calls) as calls, sum(rows) as rows from pg_stat_statements_normalized p group by dbid, userid, md5(query_normalized) ), totals_readable as ( select to_char(interval ''1 millisecond'' * total_exec_time, ''HH24:MI:SS'') as total_exec_time, (100*io_time/total_exec_time)::numeric(20,2) as io_time_percent, to_char(ncalls, ''FM999,999,999,990'') as total_queries, (select to_char(count(distinct md5(query)), ''FM999,999,990'') from _pg_stat_statements) as unique_queries from totals ), statements as ( select (100*total_exec_time/(select total_exec_time from totals)) as time_percent, (100*(blk_read_time+blk_write_time)/(select greatest(io_time, 1) from totals)) as io_time_percent, (100*(total_exec_time-blk_read_time-blk_write_time)/(select non_io_time from totals)) as non_io_time_percent, to_char(interval ''1 millisecond'' * total_exec_time, ''HH24:MI:SS'') as total_exec_time, (total_exec_time::numeric/calls)::numeric(20,2) as avg_time, ((total_exec_time-blk_read_time-blk_write_time)::numeric/calls)::numeric(20, 2) as avg_non_io_time, ((blk_read_time+blk_write_time)::numeric/calls)::numeric(20, 2) as avg_io_time, to_char(calls, ''FM999,999,999,990'') as calls, (100*calls/(select ncalls from totals))::numeric(20, 2) as calls_percent, to_char(rows, ''FM999,999,999,990'') as rows, (100*rows/(select total_rows from totals))::numeric(20, 2) as row_percent, database, username, query from _pg_stat_statements where (total_exec_time-blk_read_time-blk_write_time)/(select non_io_time from totals) >= 0.01 or (blk_read_time+blk_write_time)/( select greatest(io_time, 1) from totals ) >= 0.01 or calls/(select ncalls from totals) >= 0.02 or rows/(select total_rows from totals) >= 0.02 union all select (100*sum(total_exec_time)::numeric/(select total_exec_time from totals)) as time_percent, (100*sum(blk_read_time+blk_write_time)::numeric/(select greatest(io_time, 1) from totals)) as io_time_percent, (100*sum(total_exec_time-blk_read_time-blk_write_time)::numeric/(select non_io_time from totals)) as non_io_time_percent, to_char(interval ''1 millisecond'' * sum(total_exec_time), ''HH24:MI:SS'') as total_exec_time, (sum(total_exec_time)::numeric/sum(calls))::numeric(20,2) as avg_time, (sum(total_exec_time-blk_read_time-blk_write_time)::numeric/sum(calls))::numeric(20, 2) as avg_non_io_time, (sum(blk_read_time+blk_write_time)::numeric/sum(calls))::numeric(20, 2) as avg_io_time, to_char(sum(calls), ''FM999,999,999,990'') as calls, (100*sum(calls)/(select ncalls from totals))::numeric(20, 2) as calls_percent, to_char(sum(rows), ''FM999,999,999,990'') as rows, (100*sum(rows)/(select total_rows from totals))::numeric(20, 2) as row_percent, ''all'' as database, ''all'' as username, ''other'' as query from _pg_stat_statements where not ( (total_exec_time-blk_read_time-blk_write_time)/(select non_io_time from totals) >= 0.01 or (blk_read_time+blk_write_time)/(select greatest(io_time, 1) from totals) >= 0.01 or calls/(select ncalls from totals)>=0.02 or rows/(select total_rows from totals) >= 0.02 ) ), statements_readable as ( select row_number() over (order by s.time_percent desc) as pos, to_char(time_percent, ''FM990.0'') || ''%'' as time_percent, to_char(io_time_percent, ''FM990.0'') || ''%'' as io_time_percent, to_char(non_io_time_percent, ''FM990.0'') || ''%'' as non_io_time_percent, to_char(avg_io_time*100/(coalesce(nullif(avg_time, 0), 1)), ''FM990.0'') || ''%'' as avg_io_time_percent, total_exec_time, avg_time, avg_non_io_time, avg_io_time, calls, calls_percent, rows, row_percent, database, username, left(query, 100) as query from statements s where calls is not null ) select e''total time:\t'' || total_exec_time || '' (IO: '' || io_time_percent || E''%)\n'' || e''total queries:\t'' || total_queries || '' (unique: '' || unique_queries || E'')\n'' || ''report for '' || (select case when current_database() = ''postgres'' then ''all databases'' else current_database() || '' database'' end) || E'', version b0.9.6'' || '' @ PostgreSQL '' || (select setting from pg_settings where name=''server_version'') || E''\ntracking '' || (select setting from pg_settings where name=''pg_stat_statements.track'') || '' '' || (select setting from pg_settings where name=''pg_stat_statements.max'') || '' queries, utilities '' || (select setting from pg_settings where name=''pg_stat_statements.track_utility'') || '', logging '' || (select (case when setting = ''0'' then ''all'' when setting = ''-1'' then ''none'' when setting::int > 1000 then (setting::numeric/1000)::numeric(20, 1) || ''s+'' else setting || ''ms+'' end) from pg_settings where name=''log_min_duration_statement'') || E'' queries\n'' || ( select coalesce(string_agg(''WARNING: database '' || datname || '' must be vacuumed within '' || to_char(2147483647 - age(datfrozenxid), ''FM999,999,999,990'') || '' transactions'', E''\n'' order by age(datfrozenxid) desc) || E''\n'', '''') from pg_database where (2147483647 - age(datfrozenxid)) < 200000000 ) || E''\n'' from totals_readable union all ( select e''=============================================================================================================\n'' || ''pos:'' || pos || E''\t total time: '' || total_exec_time || '' ('' || time_percent || '', IO: '' || io_time_percent || '', Non-IO: '' || non_io_time_percent || E'')\t calls: '' || calls || '' ('' || calls_percent || E''%)\t avg_time: '' || avg_time || ''ms (IO: '' || avg_io_time_percent || E'')\n'' || ''user: '' || username || E''\t db: '' || database || E''\t rows: '' || rows || '' ('' || row_percent || ''%)'' || E''\t query:\n'' || query || E''\n'' from statements_readable order by pos );'
\set vacuum_activity 'with data as ( select p.pid as pid, (select spcname from pg_tablespace where oid = reltablespace) as tblspace, p.datname as database, nspname as schema_name, relname as table_name, (now() - a.xact_start) as duration, coalesce(wait_event_type || ''. ''|| wait_event, null) as waiting, case when a.query ~*  ''^autovacuum.*to prevent wraparound '' then  ''wraparound '' when a.query ~*  ''^vacuum '' then  ''user '' else  ''auto '' end as mode, p.phase, pg_size_pretty(pg_total_relation_size(relid)) as total_size, pg_size_pretty(pg_total_relation_size(relid) - pg_indexes_size(relid)) as table_size, pg_size_pretty(pg_indexes_size(relid)) as index_size, pg_size_pretty(p.heap_blks_scanned * current_setting( ''block_size '')::int) as scanned, pg_size_pretty(p.heap_blks_vacuumed * current_setting( ''block_size '')::int) as vacuumed, round(100.0 * p.heap_blks_scanned / p.heap_blks_total, 2) as scanned_pct, round(100.0 * p.heap_blks_vacuumed / p.heap_blks_total, 2) as vacuumed_pct, p.index_vacuum_count, round(100.0 * p.num_dead_tuples / p.max_dead_tuples, 2) as dead_pct, p.num_dead_tuples, p.max_dead_tuples from pg_stat_progress_vacuum p left join pg_stat_activity a using (pid) left join pg_class c on c.oid = p.relid left join pg_namespace n on n.oid = c.relnamespace ) select pid as "PID", duration::interval(0)::text as "Duration", mode as "Mode", database || coalesce( e ''\n '' || coalesce(nullif(schema_name,  ''public '') ||  ''. '',  '' '') || table_name || coalesce( '' [ '' || tblspace ||  ''] '',  '' ''),  '' '' ) as "DB & Table", table_size as "Table", index_size as "Indexes", waiting as "Wait", phase as "Phase", scanned ||  '' ( '' || scanned_pct ||  ''%) '' || e '' scanned\n '' || vacuumed ||  '' ( '' || vacuumed_pct ||  ''%) vacuumed '' as "Heap Vacuuming", index_vacuum_count ||  '' completed cycles, '' || e ''\n '' || case when num_dead_tuples > 10^12 then round(num_dead_tuples::numeric / 10^12::numeric, 0)::text ||  ''T '' when num_dead_tuples > 10^9 then round(num_dead_tuples::numeric / 10^9::numeric, 0)::text ||  ''B '' when num_dead_tuples > 10^6 then round(num_dead_tuples::numeric / 10^6::numeric, 0)::text ||  ''M '' when num_dead_tuples > 10^3 then round(num_dead_tuples::numeric / 10^3::numeric, 0)::text ||  ''k '' else num_dead_tuples::text end ||  '' ( '' || dead_pct || e ''%) dead tuples\nof max ~ '' || case when max_dead_tuples > 10^12 then round(max_dead_tuples::numeric / 10^12::numeric, 0)::text ||  ''T '' when max_dead_tuples > 10^9 then round(max_dead_tuples::numeric / 10^9::numeric, 0)::text ||  ''B '' when max_dead_tuples > 10^6 then round(max_dead_tuples::numeric / 10^6::numeric, 0)::text ||  ''M '' when max_dead_tuples > 10^3 then round(max_dead_tuples::numeric / 10^3::numeric, 0)::text ||  ''k '' else max_dead_tuples::text end ||  '' collected now '' as "Index Vacuuming" from data order by duration desc;'
\set autovacuum_progress_and_queue 'with table_opts as ( select pg_class.oid, relname, nspname, array_to_string(reloptions, '''') as relopts from pg_class join pg_namespace ns on relnamespace = ns.oid ), vacuum_settings as ( select oid, relname, nspname, case when relopts like ''%autovacuum_vacuum_threshold%'' then regexp_replace(relopts, ''.*autovacuum_vacuum_threshold=([0-9.]+).*'', E''\\1'')::int8 else current_setting(''autovacuum_vacuum_threshold'')::int8 end as autovacuum_vacuum_threshold, case when relopts like ''%autovacuum_vacuum_scale_factor%'' then regexp_replace(relopts, ''.*autovacuum_vacuum_scale_factor=([0-9.]+).*'', E''\\1'')::numeric else current_setting(''autovacuum_vacuum_scale_factor'')::numeric end as autovacuum_vacuum_scale_factor, case when relopts ~ ''autovacuum_enabled=(false|off)'' then false else true end as autovacuum_enabled from table_opts ), p as ( select * from pg_stat_progress_vacuum ) select coalesce( coalesce(nullif(vacuum_settings.nspname, ''public'') || ''.'', '''') || vacuum_settings.relname, format(''[something in "%I"]'', p.datname) ) as table, round((100 * psat.n_dead_tup::numeric / nullif(pg_class.reltuples, 0))::numeric, 2) as dead_tup_pct, pg_class.reltuples::numeric, psat.n_dead_tup, ''vt: '' || vacuum_settings.autovacuum_vacuum_threshold || '', vsf: '' || vacuum_settings.autovacuum_vacuum_scale_factor || case when not autovacuum_enabled then '', DISABLED'' else '', enabled'' end as "effective_settings", case when last_autovacuum > coalesce(last_vacuum, ''0001-01-01'') then left(last_autovacuum::text, 19) || '' (auto)'' when last_vacuum is not null then left(last_vacuum::text, 19) || '' (manual)'' else null end as "last_vacuumed", coalesce(p.phase, ''~~~ in queue ~~~'') as status, p.pid as pid, case when a.query ~ ''^autovacuum.*to prevent wraparound'' then ''wraparound'' when a.query ~ ''^vacuum'' then ''user'' when a.pid is null then null else ''regular'' end as mode, case when a.pid is null then null else coalesce(wait_event_type ||''.''|| wait_event, ''f'') end as waiting, round(100.0 * p.heap_blks_scanned / nullif(p.heap_blks_total, 0), 1) AS scanned_pct, round(100.0 * p.heap_blks_vacuumed / nullif(p.heap_blks_total, 0), 1) AS vacuumed_pct, p.index_vacuum_count, case when psat.relid is not null and p.relid is not null then (select count(*) from pg_index where indrelid = psat.relid) else null end as index_count from pg_stat_all_tables psat join pg_class on psat.relid = pg_class.oid join vacuum_settings on pg_class.oid = vacuum_settings.oid full outer join p on p.relid = psat.relid and p.datname = current_database() left join pg_stat_activity a using (pid) where psat.relid is null or autovacuum_vacuum_threshold + (autovacuum_vacuum_scale_factor::numeric * pg_class.reltuples) < psat.n_dead_tup;'
\set blockers_of_queries_alter_table 'SELECT blockers.pid, blockers.usename, blockers.query_start, blockers.query FROM pg_stat_activity blockers INNER JOIN (SELECT pg_blocking_pids(pid) blocking_pids FROM pg_stat_activity WHERE pid != pg_backend_pid() AND query LIKE ''ALTER TABLE%'' ) my_query ON blockers.pid = ANY(my_query.blocking_pids);'
\set blockers_of_queries_all 'SELECT a1.pid, a1.usename, (now() - a1.query_start) AS running_time, pg_blocking_pids(a1.pid) AS blocked_by, a1.query AS blocked_query, a2.query AS blocking_query FROM pg_stat_activity AS a1 INNER JOIN pg_stat_activity AS a2 ON (a2.pid = (pg_blocking_pids(a1.pid)::integer[])[1]) WHERE cardinality(pg_blocking_pids(a1.pid)) > 0;'
\set kill_autovacuums 'SELECT pg_terminate_backend(pid), query, now() - pg_stat_activity.query_start AS duration FROM pg_stat_activity WHERE query ilike ''autovacuum:%'';'
\set table_ages 'SELECT c.oid::regclass, age(c.relfrozenxid), pg_size_pretty(pg_total_relation_size(c.oid)) FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid WHERE relkind IN (''r'', ''t'', ''m'') AND n.nspname NOT IN (''pg_toast'') ORDER BY 2 DESC LIMIT 20;'
\set connection_counts_by_application 'SELECT application_name, state, count(*) FROM pg_stat_activity GROUP BY application_name, state;'
\set connection_counts_by_state 'SELECT state, count(*) FROM pg_stat_activity GROUP BY state;'
\set index_monitoring 'SELECT now(), query_start AS started_at, now() - query_start AS query_duration, format(''[%s] %s'', a.pid, a.query) AS pid_and_query, index_relid::regclass AS index_name, relid::regclass AS TABLE_NAME, (pg_size_pretty(pg_relation_size(relid))) AS table_size, nullif(wait_event_type, '''') || '': '' || wait_event AS wait_type_and_event, phase, format(''%s (%s of %s)'', coalesce((round(100 * blocks_done::numeric / nullif(blocks_total, 0), 2))::text || ''%'', ''N/A''), coalesce(blocks_done::text, ''?''), coalesce(blocks_total::text, ''?'')) AS blocks_progress, format(''%s (%s of %s)'', coalesce((round(100 * tuples_done::numeric / nullif(tuples_total, 0), 2))::text || ''%'', ''N/A''), coalesce(tuples_done::text, ''?''), coalesce(tuples_total::text, ''?'')) AS tuples_progress, current_locker_pid, (SELECT nullif(left(query, 150), '''') || ''...'' FROM pg_stat_activity a WHERE a.pid = current_locker_pid) AS current_locker_query, format(''%s (%s of %s)'', coalesce((round(100 * lockers_done::numeric / nullif(lockers_total, 0), 2))::text || ''%'', ''N/A''), coalesce(lockers_done::text, ''?''), coalesce(lockers_total::text, ''?'')) AS lockers_progress, format(''%s (%s of %s)'', coalesce((round(100 * partitions_done::numeric / nullif(partitions_total, 0), 2))::text || ''%'', ''N/A''), coalesce(partitions_done::text, ''?''), coalesce(partitions_total::text, ''?'')) AS partitions_progress, (SELECT format(''%s (%s of %s)'', coalesce((round(100 * n_dead_tup::numeric / nullif(reltuples::numeric, 0), 2))::text || ''%'', ''N/A''), coalesce(n_dead_tup::text, ''?''), coalesce(reltuples::int8::text, ''?'')) FROM pg_stat_all_tables t, pg_class tc WHERE t.relid = p.relid AND tc.oid = p.relid ) AS table_dead_tuples FROM pg_stat_progress_create_index p LEFT JOIN pg_stat_activity a ON a.pid = p.pid ORDER BY p.index_relid;'
\set analyze_vacuum_stats 'WITH raw_data AS (SELECT pg_namespace.nspname, pg_class.relname, pg_class.oid AS relid, pg_class.reltuples, pg_stat_all_tables.n_dead_tup, pg_stat_all_tables.n_mod_since_analyze, (SELECT split_part(x, ''='', 2) FROM unnest(pg_class.reloptions) q (x) WHERE x ~ ''^autovacuum_analyze_scale_factor='' ) AS c_analyze_factor, (SELECT split_part(x, ''='', 2) FROM unnest(pg_class.reloptions) q (x) WHERE x ~ ''^autovacuum_analyze_threshold='' ) AS c_analyze_threshold, (SELECT split_part(x, ''='', 2) FROM unnest(pg_class.reloptions) q (x) WHERE x ~ ''^autovacuum_vacuum_scale_factor='' ) AS c_vacuum_factor, (SELECT split_part(x, ''='', 2) FROM unnest(pg_class.reloptions) q (x) WHERE x ~ ''^autovacuum_vacuum_threshold='' ) AS c_vacuum_threshold, to_char(pg_stat_all_tables.last_vacuum, ''YYYY-MM-DD HH24:MI:SS'') AS last_vacuum, to_char(pg_stat_all_tables.last_autovacuum, ''YYYY-MM-DD HH24:MI:SS'') AS last_autovacuum, to_char(pg_stat_all_tables.last_analyze, ''YYYY-MM-DD HH24:MI:SS'') AS last_analyze, to_char(pg_stat_all_tables.last_autoanalyze, ''YYYY-MM-DD HH24:MI:SS'') AS last_autoanalyze FROM pg_class JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid LEFT OUTER JOIN pg_stat_all_tables ON pg_class.oid = pg_stat_all_tables.relid WHERE n_dead_tup IS NOT NULL AND nspname NOT IN (''information_schema'', ''pg_catalog'') AND nspname NOT LIKE ''pg_toast%'' AND pg_class.relkind = ''r'' ), DATA AS (SELECT *, COALESCE(raw_data.c_analyze_factor, current_setting(''autovacuum_analyze_scale_factor''))::float8 AS analyze_factor, COALESCE(raw_data.c_analyze_threshold, current_setting(''autovacuum_analyze_threshold''))::float8 AS analyze_threshold, COALESCE(raw_data.c_vacuum_factor, current_setting(''autovacuum_vacuum_scale_factor''))::float8 AS vacuum_factor, COALESCE(raw_data.c_vacuum_threshold, current_setting(''autovacuum_vacuum_threshold''))::float8 AS vacuum_threshold FROM raw_data) SELECT relname, reltuples, n_dead_tup, n_mod_since_analyze, ROUND(reltuples * vacuum_factor + vacuum_threshold) AS v_threshold, ROUND(reltuples * analyze_factor + analyze_threshold) AS a_threshold, ROUND(CAST(n_dead_tup/(reltuples * vacuum_factor + vacuum_threshold)*100 AS numeric), 2) AS v_percent, ROUND(CAST(n_mod_since_analyze/(reltuples * analyze_factor + analyze_threshold)*100 AS numeric), 2) AS a_percent, last_vacuum, last_autovacuum, last_analyze, last_autoanalyze FROM DATA ORDER BY a_percent DESC;'

\unset QUIET
